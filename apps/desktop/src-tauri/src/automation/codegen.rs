use anyhow::Result;
use serde::{Deserialize, Serialize};

use super::executor::{AutomationScript, ScriptAction};

/// Code language options
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "lowercase")]
pub enum CodeLanguage {
    Python,
    Rust,
    JavaScript,
    TypeScript,
}

/// Generated code with dependencies
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GeneratedCode {
    pub language: CodeLanguage,
    pub code: String,
    pub dependencies: Vec<String>,
}

/// Code generator service
pub struct CodeGenerator;

impl CodeGenerator {
    pub fn generate(script: &AutomationScript, language: CodeLanguage) -> Result<GeneratedCode> {
        match language {
            CodeLanguage::Python => Self::generate_python(script),
            CodeLanguage::Rust => Self::generate_rust(script),
            CodeLanguage::JavaScript => Self::generate_javascript(script),
            CodeLanguage::TypeScript => Self::generate_typescript(script),
        }
    }

    fn generate_python(script: &AutomationScript) -> Result<GeneratedCode> {
        let mut code = String::new();

        // Header
        code.push_str("#!/usr/bin/env python3\n");
        code.push_str("\"\"\"");
        code.push_str(&format!("\nAutomation Script: {}\n", script.name));
        code.push_str(&format!("{}\n", script.description));
        code.push_str("\nGenerated by AGI Workforce Desktop App\n");
        code.push_str("\"\"\"\n\n");

        // Imports
        code.push_str("import time\n");
        code.push_str("import pyautogui\n");
        code.push_str("from pywinauto import Desktop\n");
        code.push_str("from pywinauto.application import Application\n\n");

        // Configuration
        code.push_str("# Fail-safe: Move mouse to corner to abort\n");
        code.push_str("pyautogui.FAILSAFE = True\n");
        code.push_str("pyautogui.PAUSE = 0.5  # Pause between actions\n\n");

        // Main function
        code.push_str("def main():\n");
        code.push_str("    \"\"\"Execute automation script\"\"\"\n");
        code.push_str("    print(f\"Starting automation: {}\")\n\n");

        // Generate actions
        for (index, action) in script.actions.iter().enumerate() {
            code.push_str(&format!("    # Action {}: {}\n", index + 1, action.action_type));
            code.push_str("    try:\n");

            match action.action_type.as_str() {
                "click" => {
                    if let Some(ref coords) = action.coordinates {
                        code.push_str(&format!("        pyautogui.click({}, {})\n", coords.x, coords.y));
                        code.push_str(&format!("        print(\"Clicked at ({}, {})\")\n", coords.x, coords.y));
                    }
                }
                "type" => {
                    if let Some(ref text) = action.value {
                        code.push_str(&format!("        pyautogui.write(\"{}\")\n", text.replace("\"", "\\\"")));
                        code.push_str("        print(\"Typed text\")\n");
                    }
                }
                "wait" => {
                    let duration = action.duration.unwrap_or(1000) as f64 / 1000.0;
                    code.push_str(&format!("        time.sleep({:.2})\n", duration));
                    code.push_str(&format!("        print(\"Waited {:.2} seconds\")\n", duration));
                }
                "screenshot" => {
                    code.push_str("        screenshot = pyautogui.screenshot()\n");
                    code.push_str(&format!("        screenshot.save('screenshot_{}.png')\n", index));
                    code.push_str("        print(\"Screenshot taken\")\n");
                }
                "hotkey" => {
                    if let Some(ref value) = action.value {
                        let keys: Vec<&str> = value.split('+').map(|s| s.trim()).collect();
                        let keys_str = keys.iter()
                            .map(|k| format!("\"{}\"", k.to_lowercase()))
                            .collect::<Vec<_>>()
                            .join(", ");
                        code.push_str(&format!("        pyautogui.hotkey({})\n", keys_str));
                        code.push_str(&format!("        print(\"Pressed hotkey: {}\")\n", value));
                    }
                }
                "drag" => {
                    if let Some(ref coords) = action.coordinates {
                        // Parse target from metadata
                        code.push_str(&format!("        pyautogui.drag({}, {}, duration=0.5)\n", coords.x, coords.y));
                        code.push_str("        print(\"Drag action completed\")\n");
                    }
                }
                _ => {
                    code.push_str(&format!("        # Unsupported action: {}\n", action.action_type));
                }
            }

            code.push_str("    except Exception as e:\n");
            code.push_str(&format!("        print(f\"Error in action {}: {{e}}\")\n", index + 1));
            code.push_str("        raise\n\n");
        }

        code.push_str("    print(\"Automation completed successfully!\")\n\n");

        // Entry point
        code.push_str("if __name__ == \"__main__\":\n");
        code.push_str("    try:\n");
        code.push_str("        main()\n");
        code.push_str("    except KeyboardInterrupt:\n");
        code.push_str("        print(\"\\nAutomation aborted by user\")\n");
        code.push_str("    except Exception as e:\n");
        code.push_str("        print(f\"Automation failed: {e}\")\n");
        code.push_str("        raise\n");

        Ok(GeneratedCode {
            language: CodeLanguage::Python,
            code,
            dependencies: vec![
                "pyautogui".to_string(),
                "pywinauto".to_string(),
            ],
        })
    }

    fn generate_rust(script: &AutomationScript) -> Result<GeneratedCode> {
        let mut code = String::new();

        // Header
        code.push_str("//! Automation Script\n");
        code.push_str(&format!("//! Name: {}\n", script.name));
        code.push_str(&format!("//! Description: {}\n", script.description));
        code.push_str("//! Generated by AGI Workforce Desktop App\n\n");

        // Imports
        code.push_str("use std::thread;\n");
        code.push_str("use std::time::Duration;\n");
        code.push_str("use windows::Win32::UI::Input::KeyboardAndMouse::*;\n");
        code.push_str("use windows::Win32::UI::WindowsAndMessaging::*;\n\n");

        // Main function
        code.push_str("fn main() -> Result<(), Box<dyn std::error::Error>> {\n");
        code.push_str(&format!("    println!(\"Starting automation: {}\");\n\n", script.name));

        // Generate actions
        for (index, action) in script.actions.iter().enumerate() {
            code.push_str(&format!("    // Action {}: {}\n", index + 1, action.action_type));

            match action.action_type.as_str() {
                "click" => {
                    if let Some(ref coords) = action.coordinates {
                        code.push_str("    unsafe {\n");
                        code.push_str(&format!("        SetCursorPos({}, {});\n", coords.x, coords.y));
                        code.push_str("        mouse_event(MOUSEEVENTF_LEFTDOWN, 0, 0, 0, 0);\n");
                        code.push_str("        mouse_event(MOUSEEVENTF_LEFTUP, 0, 0, 0, 0);\n");
                        code.push_str("    }\n");
                        code.push_str(&format!("    println!(\"Clicked at ({}, {})\");\n\n", coords.x, coords.y));
                    }
                }
                "type" => {
                    if let Some(ref text) = action.value {
                        code.push_str(&format!("    // Type text: {}\n", text.replace("\"", "\\\"")));
                        code.push_str("    // Note: Text input requires more complex implementation\n");
                        code.push_str(&format!("    println!(\"Typed: {}\");\n\n", text.replace("\"", "\\\"")));
                    }
                }
                "wait" => {
                    let duration = action.duration.unwrap_or(1000);
                    code.push_str(&format!("    thread::sleep(Duration::from_millis({}));\n", duration));
                    code.push_str(&format!("    println!(\"Waited {} ms\");\n\n", duration));
                }
                "screenshot" => {
                    code.push_str("    // Screenshot implementation needed\n");
                    code.push_str("    println!(\"Screenshot taken\");\n\n");
                }
                _ => {
                    code.push_str(&format!("    // Unsupported action: {}\n\n", action.action_type));
                }
            }
        }

        code.push_str("    println!(\"Automation completed successfully!\");\n");
        code.push_str("    Ok(())\n");
        code.push_str("}\n");

        Ok(GeneratedCode {
            language: CodeLanguage::Rust,
            code,
            dependencies: vec![
                "windows = { version = \"0.58\", features = [\"Win32_UI_Input_KeyboardAndMouse\", \"Win32_UI_WindowsAndMessaging\"] }".to_string(),
            ],
        })
    }

    fn generate_javascript(script: &AutomationScript) -> Result<GeneratedCode> {
        let mut code = String::new();

        // Header
        code.push_str("/**\n");
        code.push_str(&format!(" * Automation Script: {}\n", script.name));
        code.push_str(&format!(" * Description: {}\n", script.description));
        code.push_str(" * Generated by AGI Workforce Desktop App\n");
        code.push_str(" */\n\n");

        // Imports
        code.push_str("const robot = require('robotjs');\n\n");

        // Main function
        code.push_str("async function main() {\n");
        code.push_str(&format!("  console.log('Starting automation: {}');\n\n", script.name));

        // Generate actions
        for (index, action) in script.actions.iter().enumerate() {
            code.push_str(&format!("  // Action {}: {}\n", index + 1, action.action_type));

            match action.action_type.as_str() {
                "click" => {
                    if let Some(ref coords) = action.coordinates {
                        code.push_str(&format!("  robot.moveMouse({}, {});\n", coords.x, coords.y));
                        code.push_str("  robot.mouseClick();\n");
                        code.push_str(&format!("  console.log('Clicked at ({}, {})');\n\n", coords.x, coords.y));
                    }
                }
                "type" => {
                    if let Some(ref text) = action.value {
                        code.push_str(&format!("  robot.typeString('{}');\n", text.replace("'", "\\'")));
                        code.push_str("  console.log('Typed text');\n\n");
                    }
                }
                "wait" => {
                    let duration = action.duration.unwrap_or(1000);
                    code.push_str(&format!("  await new Promise(resolve => setTimeout(resolve, {}));\n", duration));
                    code.push_str(&format!("  console.log('Waited {} ms');\n\n", duration));
                }
                _ => {
                    code.push_str(&format!("  // Unsupported action: {}\n\n", action.action_type));
                }
            }
        }

        code.push_str("  console.log('Automation completed successfully!');\n");
        code.push_str("}\n\n");

        // Entry point
        code.push_str("main().catch(err => {\n");
        code.push_str("  console.error('Automation failed:', err);\n");
        code.push_str("  process.exit(1);\n");
        code.push_str("});\n");

        Ok(GeneratedCode {
            language: CodeLanguage::JavaScript,
            code,
            dependencies: vec!["robotjs".to_string()],
        })
    }

    fn generate_typescript(script: &AutomationScript) -> Result<GeneratedCode> {
        let mut result = Self::generate_javascript(script)?;

        // Add TypeScript type annotations
        let code = result.code
            .replace("async function main() {", "async function main(): Promise<void> {")
            .replace("const robot = require('robotjs');", "import * as robot from 'robotjs';");

        result.code = code;
        result.language = CodeLanguage::TypeScript;
        result.dependencies.push("@types/robotjs".to_string());

        Ok(result)
    }
}
